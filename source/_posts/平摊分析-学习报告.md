---
title: 平摊分析 学习报告
date: 2019-07-16 14:25:45
tags:
	- 时间复杂度分析
	- 数据结构
categories: 学习报告
top:
toc: true
---

# ~~前言？~~

![](https://i.loli.net/2019/07/16/5d2d809f4909830780.png)

![](https://i.loli.net/2019/07/16/5d2d80ba10ac722018.png)

![](https://i.loli.net/2019/07/16/5d2d80c913c3a98149.png)

![](https://i.loli.net/2019/07/16/5d2d80d64baa048100.png)

![](https://i.loli.net/2019/07/16/5d2d80e2b7cf868820.png)

在b站上看MIT的课学了这个玩意...

本来以为平摊分析与势能分析是两个玩意，看完之后发现自己太naive了。

<!--more-->

# 问题引入

> Hash表应该开多大？

- 从**时间**上考虑

一般来说，Hash表开的越**大**，查找时间就越**短**，当一个Hash表足够大的时候，它就成了一个**直接映射表**，查找时间**最差**为$O(1)$

- 从**空间**上考虑

我们希望它尽可能的**小**，这样就不会**浪费空间**。

综合考虑上述两点，我们得到一个**折中值**：

对于**n个元素**，Hash表的大小的最好的折中值为$\Theta(n)$

> 但是，如果我们不知道将要加入的元素个数呢？

这个问题的解是**动态表（Dynamic Tables）**

当一个普通的Hash表**溢出（Overflow）**时，就增大空间。

（有点`vector`的感觉）

> 增大空间的方法？

- 分配一个**更大的表**（`malloc()`），然后将元素从旧表迁移到新表，然后释放旧表的空间。（似乎非常的慢。）

假设有一个大小为1的空的Hash表。

这里我们**不考虑Hash的过程**，来直接模拟**溢出及分配**的过程：

| Operation | Table Size | Elements |
| :-------: | :--------: | :------: |
| Insert(1) |     1      |    1     |
| Insert(2) |     2      |   1 2    |
| Insert(3) |   **4**    |  1 2 3   |
| Insert(4) |     4      | 1 2 3 4  |

可以发现，表的扩张是**倍增**实现的

对此方法做分析：

> 有一个序列，包括n次插入运算，求最坏情况下，一次插入的代价？

对于任何元素，最差的情况是在**插入时，表会溢出**，这时需要将旧表中的**每一项**都复制到新表中，所以在**最差情况**下，一次插入的代价为$\Theta(n)$

所以最差情况下，$n$次插入的总代价=$n \times \Theta(n) = \Theta(n ^ 2)$

你没发现上一句话没东西加粗嘛？

因为它假了。

稍加观察可以发现，并不是每个元素在插入时**都处在最差情况**，实际上，最差情况下，n次插入的**总代价**依然是

$\Theta(n)$

简略证明：
设第i次插入的代价为$c_i$

由于扩张是倍增实现的，所以在插入第二的整数幂加一个整数时，表会发生扩张，此时插入的代价为$\Theta ( n ) $

$$\therefore  c_i = \begin{cases} i & \log_2(x - 1) \in \mathbb N \\ \\ 1 & Otherwise\end{cases}$$

对每一项分析代价，列出如下表格：

|     项数     |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :----------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **表的大小** |  1   |  2   |  4   |  4   |  8   |  8   |  8   |  8   |  16  |
| **插入代价** |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |
| **扩张代价** |  0   |  1   |  2   |  0   |  4   |  0   |  0   |  0   |  8   |

观察表的规律，对代价求和得：

​    总代价

$=\sum\limits_{i = 1} ^ n c_i$

$= n + \sum\limits_{j = 0} ^{\lfloor\log_2(n - 1)\rfloor} 2 ^ j$

第二项是一个几何级数，上界由最大值决定，所以我们得到：

$$\sum\limits_{j = 0}^{\lfloor\log_2(n - 1)\rfloor} 2^j\le 2n$$

所以$n + \sum\limits^{\lfloor\log_2(n - 1)\rfloor} _ {j = 0} \le 3n = \Theta(n)$

所以**总代价**为$\Theta(n )$

所以每次插入的平均代价为$\frac{\Theta(n)}{n} = \Theta(1)$

这就是对Hash表插入操作的**平摊分析**

# 平摊分析

## 特性

由上面的例子我们很容易发现平摊分析的一个特性：
尽管一个操作序列中，**部分操作**的代价可能**比较大**，但是对它的平摊分析表示这个操作序列中**每个操作**的**平均代价**很**小**。

这是**最差情况**下的平均表现，**不涉及概率**。

## 意义

平摊分析给出了**最坏情况下的整个操作序列的代价上界**。

## 三种方法

- 聚集分析

正如**上面的例子**展现的方法。基本上是分析**整个操作序列**的花费时间，并不能轻易钦定某一个操作的时间复杂度。（例题是特殊情况）

- 记账方法
- 势能分析

下面两者更加精确，它们为**每一个操作**分配了**特定的**平摊代价。

# 回顾例题

我们现在~~闲的蛋疼~~用后两种方法来分析分析。

## 记账方法

还没看完咕咕咕咕咕...