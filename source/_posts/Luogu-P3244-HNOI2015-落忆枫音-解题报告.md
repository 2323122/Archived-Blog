---
title: Luogu P3244 [HNOI2015]落忆枫音 解题报告
categories: 解题报告
date: 2019-08-03 08:40:27
tags:
	- 组合计数
	- 图论
	- DP
top:
---

# 题目链接

[P3244 [HNOI2015]落忆枫音](https://www.luogu.org/problem/P3244)

# 题目背景

这个题目背景我一定要放上来（

<!--more-->

**「恒逸，你相信灵魂的存在吗？」** 郭恒逸和姚枫茜漫步在枫音乡的街道上。望着漫天飞舞的红枫，枫茜突然问出这样一个问题。

**「相信吧。不然我们是什么，一团肉吗？要不是有灵魂......我们也不可能再见到你姐姐吧。」** 恒逸给出了一个略微无厘头的回答。枫茜听后笑了笑。 **「那你仔细观察过枫叶吗？」** 说罢，枫茜伸手，接住了一片飘落的枫叶。

**「其实每一片枫叶都是有灵魂的。你看，枫叶上不是有这么多脉络吗？我听说，枫叶上有一些特殊的位置，就和人的穴位一样。脉络都是连接在这些穴位之间的。枫树的灵魂流过每片枫叶的根部，沿着这些脉络，慢慢漫进穴位，沁入整片枫叶。也是因为这个原因，脉络才都是单向的，灵魂可不能倒着溜回来呢。」** 恒逸似懂非懂地点了点头。枫茜接着说了下去。

**「正是因为有了灵魂，每片枫叶才会与众不同。也正是因为有了灵魂，每片枫叶也都神似其源本的枫树，就连脉络也形成了一棵树的样子。但如果仔细看的话，会发现，在脉络树之外，还存在其它的非常细的脉络。虽然这些脉络并不在树上，但他们的方向也同样顺着灵魂流淌的方向，绝不会出现可能使灵魂倒流的回路。」** 恒逸好像突然想到了什么。 **「那这些脉络岂不是可以取代已有的脉络，出现在脉络树上？」** 枫茜闭上了眼睛。

**「是啊，就是这样。脉络树并不是唯一的。只要有一些微小的偏差，脉络树就可能差之万里，哪怕是在这同一片枫叶上。就像我们的故事，结局也不是唯一的。只要改变一个小小的选项，故事流程可能就会被彻底扭转。」**

**「真是深奥啊......」** 恒逸盯着这片红枫，若有所思地说。枫茜继续说道。

**「还不止如此呢。所有的脉络都不会永恒存在，也不会永恒消失。不管是脉络树上的脉络，还是之外的细小脉络，都是如此。存在的脉络可能断开消失，消失的脉络也可能再次连接。万物皆处在永恒的变化之中，人与人之间的羁绊也是。或许有一天，我们与大家的羁绊也会如同脉络一样，被无情地斩断。或许我们也终将成为”枫音乡的过客“。或许这一切都会是必然，是枫树的灵魂所决定的......」**

枫茜的眼角泛起了几滴晶莹剔透的泪珠。恒逸看着这样的枫茜，将她抱入怀中。

**「别这样想，枫茜。就算脉络断开，也有可能还会有新的脉络树，也还会与枫树的根相连。这样的话，我们的羁绊仍然存在，只是稍微绕了一些远路而已。无论如何，我都不会离开你的。因为你是我穷尽一生所寻找的，我的真恋啊！」**

两人的目光对上了。枫茜幸福地笑了，把头埋进了恒逸的怀抱。从远方山上的枫林中，传来了枫的声音。

# 题意描述

不妨假设枫叶上有 n个穴位，穴位的编号为 1 ~ n。有若干条有向的脉络连接着这些穴位。穴位和脉络组成一个有向无环图——称之为脉络图（例如图 1），穴位的编号使得穴位 1 没有从其他穴位连向它的脉络，即穴位 1 只有连出去的脉络；由上面的故事可知，这个有向无环图存在一个树形子图，它是以穴位 1为根的包含全部n个穴位的一棵树——称之为脉络树（例如图 2和图 3给出的树都是图1给出的脉络图的子图）；值得注意的是，脉络图中的脉络树方案可能有多种可能性，例如图2和图 3就是图 1给出的脉络图的两个脉络树方案。![img](https://cdn.luogu.org/upload/pic/11330.png)

脉络树的形式化定义为：以穴位 r 为根的脉络树由枫叶上全部 n个穴位以及 n- 1 条脉络组成，脉络树里没有环，亦不存在从一个穴位连向自身的脉络，且对于枫叶上的每个穴位 s，都存在一条唯一的包含于脉络树内的脉络路径，使得从穴位r 出发沿着这条路径可以到达穴位 s。 现在向脉络图添加一条与已有脉络不同的脉络（注意：连接 2个穴位但方向不同的脉络是不同的脉络，例如从穴位3到4的脉络与从4到3的脉络是不同的脉络，因此，图 1 中不能添加从 3 到 4 的脉络，但可添加从 4 到 3 的脉络），这条新脉络可以是从一个穴位连向自身的（例如，图 1 中可添加从 4 到 4 的脉络）。原脉络图添加这条新脉络后得到的新脉络图可能会出现脉络构成的环。 请你求出添加了这一条脉络之后的新脉络图的以穴位 1 为根的脉络树方案数。

由于方案可能有太多太多，请输出方案数对 1,000,000,007 取模得到的结果。

# 解题思想

考虑**未加边**的情况，此时图是一个**DAG**，记为$G=(V, E)$，我们需要统计它的树形子图。

考虑树的特性，每个节点有且仅有唯一一个父节点，那么我们可以根据乘法原理，将每个**非根节点**的**入度**累乘，即可得到答案为：
$$\prod\limits_{i = 2}^{n} \deg i$$

考虑加边，依然按照上面的方式统计，这样会统计到不合法答案。

我们考虑统计不合法答案，然后用原答案减去它。

可以发现，在原图的**DAG**上加一条边，若答案不合法，则这个加边后的图一定含有环。又因为原图是一个**DAG**，所以这个环一定含有加上的边。

于是可以枚举环上的点集$S$，为其**钦定父节点**，然后将**非环上节点**照旧统计，可以得到所有不合法答案，即为：
$$\sum\limits_{S}\prod\limits_{i\notin S} \deg i$$

这个答案可以**DP**出来。

设`dp[i]`表示路径$i\rightarrow x$上节点成环的情况数，那么有初始值：
$$dp[x] = \prod\limits_{y : y \in V 且 y \neq x}\deg y$$

由于我们为每个环上的节点**钦定了父节点**，所以对于一个点$x$，我们将其统计入环时，它对不合法情况的贡献会由$\deg x$变为$1$，所以转移时需要除去它的入度。

那么状态转移方程为：

$$dp[x] = \frac {\sum\limits_{y : (x, y)\in E}dp[y]} {\deg x}$$

整个DP是$O(n)$的，如果在线求逆就是$O(n \log n)$的。

最后的答案就是总方案减去不合法数，注意DP完成后节点$x$的父节点未考虑减少的贡献，所以需要除以$\deg x$，即：
$$ans = \prod\limits_{i = 2}^{n}\deg i - \frac {dp[x]} {\deg x}$$

# 参考代码

```c++
#include <cstdio>
#include <cstring>

const int MOD = 1e9 + 7;
const int N = 2e5 + 6;
const int M = N << 1;

inline int mul(int a, int b) {return 1ll * a * b % MOD;}
inline int add(int a, int b) {return a + b > MOD ? a + b - MOD : a + b;}
inline int power(int a, int b) {int res = 1; for(; b; b >>= 1, a = mul(a, a)) if(b & 1) res = mul(res, a); return res;}

int n, m, y, x, ans = 1;
int dp[N], in[N];
int head[N], nxt[M], ver[M], cnt;

inline void adde(int x, int y) {
    ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt, in[y]++;
}

int dfs(int x) {
    if(~dp[x]) return dp[x];
    dp[x] = 0;
    for(register int i = head[x]; i; i = nxt[i]) {
        int y = ver[i];
        dfs(y);
        dp[x] = add(dp[x], dp[y]);
    }
    dp[x] = mul(dp[x], power(in[x], MOD - 2));
    return dp[x];
}

int main() {
    scanf("%d%d%d%d", &n, &m, &y, &x);
    memset(dp, -1, sizeof(dp));
    dp[y] = 1;
    for(register int i = 1; i <= m; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        adde(u, v);
    }
    for(register int i = 2; i <= n; i++) {
        if(i == x) ans = mul(ans, in[i] + 1);
        else ans = mul(ans, in[i]);
        dp[y] = mul(dp[y], in[i]);
    }
    if(x == 1) return printf("%d\n", ans), 0;
    dp[y] = mul(dp[y], power(in[y], MOD - 2));
    ans = add(ans, MOD - dfs(x));
    printf("%d\n", ans);
    return 0;
}
```