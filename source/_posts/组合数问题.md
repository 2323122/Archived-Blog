---
title: Luogu P2822 组合数问题 解题报告
categories: 解题报告
date: 2019-02-13 10:14:12
tags: 
  - 组合数学
  - 组合数递推
top: 
---

> 暴力能拿90（雾

<!--more-->

![](https://i.loli.net/2019/02/13/5c637f8a0d9b4.jpg)

# 题目

## 题目描述

组合数 ${C_n^m}$表示的是从${n}$ 个物品中选出${m}$个物品的方案数。举个例子，从 ${(1,2,3)}$三个物品中选择两个物品可以有 ${(1,2),(1,3),(2,3)}$这三种选择方法。根据组合数的定义，我们可以给出计算组合数${C_n^m}$的一般公式：

$${C_n^m=\frac{n!}{m!(n-m)!}}$$

其中${n!=\prod\limits_{i=1}^ni}$；特别地，定义${0!=1}$。

小葱想知道如果给定${n,m}$和${k}$，对于所有的${0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )}$有多少对 (i,j)(*i*,*j*) 满足${C_i^j}$是${k}$的倍数。

## 输入输出格式

### 输入格式：

第一行有两个整数${t,k}$，其中代${t}$表该测试点总共有多少组测试数据，${k}$的意义见问题描述。

接下来${t}$行每行两个整数${n,m}$，其中${ n,m}$的意义见问题描述。

### 输出格式：

共$t$行，每行一个整数代表所有的$0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$中有多少对$(i,j)$满足$C_i^j$是$k$的倍数。

## 输入输出样例

输入样例#1：

```
1 2
3 3
```

输出样例#1：

```
1
```

输入样例#2：

```
2 5
4 5
6 7
```

输出样例#2：

```
0
7
```

```
7
```

## 说明

【样例1说明】

在所有可能的情况中，只有$C_2^1 = 2$是2的倍数。

【子任务】

![](https://cdn.luogu.org/upload/pic/3457.png)

# 分析

## 30分做法

照着题目打组合数公式。

优化的话，可以将阶乘打表，~~或者写INT_128将$C_{0\le i\le 2000}^{0\le j \le i}$打表~~

很无脑，没写代码。

## 50分做法

打标算，多组数据输出不换行。

就像这样![](https://i.loli.net/2019/02/13/5c63845df123d.png)

## 70分做法

发现需求出$C_{0\le i\le n}^{0\le j\le \min(i,m)}$  

考虑组合数递推：
$$ C^m_n=C^{m-1}_{n-1}+C^{m-1}_n$$

可${O(mn)}$预处理。

但需要注意**初始化**，即递推起点：
$${C_0^0=C_1^0=C_1^1=1}$$

### 实现：

```c++
void build(){
    c[0][0]=c[1][0]=c[1][1]=1;
    for(register int i=2;i<=2000;i++){
        c[i][0]=1;
        for(register int j=1;j<=i;j++){
            c[i][j]=(c[i-1][j-1]+c[i-1][j]);
        }
    }
}
```

## 90分做法

观察到**多组数据模数一致**，可以在预处理时取模。

### 实现：

```c++
void build(){
    c[0][0]=c[1][0]=c[1][1]=1;
    for(register int i=2;i<=2000;i++){
        c[i][0]=1;
        for(register int j=1;j<=i;j++){
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%k;
        }
    }
}
```

## 100分做法

观察到模数一致，考虑实现${O(1)}$查询：
用**前缀和**维护一个答案数组`ans[n][m]`，在预处理组合数时进行维护。

注意**容斥**：

```c++
ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];
```

注意对于当前数据的**更新**：

```c++
if(!c[i][j]) ans[i][j]++;
```

注意答案**传递**：（想不明白可以画一个杨辉三角手玩）

```c++
ans[i][i+1]=ans[i][i];
```

对于100分的做法，需要注意到$Sample\;2$：
在$Sample\; Input\; 2$中，出现了$m>n$的**违法情况**，对于这类数据，在答案输出时特判，输出`ans[n][n]`

# 代码

```c++
#include<cstdio>
#define ll long long

inline ll min(ll a,ll b){return a<b?a:b;}
const int maxn = 2010;
ll t,n,m,k,c[maxn][maxn],ans[maxn][maxn];

inline void build(){
    c[0][0]=c[1][0]=c[1][1]=1;
    for(register int i=2;i<=2000;i++){
        c[i][0]=1;
        for(register int j=1;j<=i;j++){
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%k;
            ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];
            if(!c[i][j]) ans[i][j]++;
        }
        ans[i][i+1]=ans[i][i];
    }
}

int main(){	
    scanf("%lld%lld",&t,&k);
    build();
    while(t--){
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",m>n?ans[n][n]:ans[n][m]);
    }
    return 0;
}
```

# 注意事项

这题坑不少，谈一谈作者实现时的问题：

1. 对于$m=0$的数据，快读有锅，应换用**标准输入输出**；
2. 多组数据题，输出时**一定要换行**！`puts("");`；
3. **容斥**和**答案继承**都是坑；
4. 若非标算，在多组数据处理前应初始化`ans`；
5. 目前没想到离线做法。